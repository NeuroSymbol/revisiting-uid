# -*- coding: utf-8 -*-
"""language_modeling.ipynb

Automatically generated by Colaboratory.

Original file is located at
        https://colab.research.google.com/drive/1GVEpsOvQu9XsJXa5qqBkCj3KpAZty-xl

If you're opening this Notebook on colab, you will probably need to install ðŸ¤— Transformers and ðŸ¤— Datasets. Uncomment the following cell and run it.
"""

# pip install datasets transformers scipy==1.5.0

# Commented out IPython magic to ensure Python compatibility.
# %load_ext rpy2.ipython
from rpy2.robjects import r, pandas2ri
pandas2ri.activate()

# Commented out IPython magic to ensure Python compatibility.
# %%R
# install.packages('lme4')
# install.packages('MuMIn')
# install.packages('lmerTest')
# install.packages('ggplot2')


import math
import torch
from transformers import GPT2LMHeadModel, GPT2TokenizerFast
import numpy as np


# Initializing a model
model = GPT2LMHeadModel.from_pretrained('gpt2')
model.eval()
# Load pre-trained model tokenizer (vocabulary)
tokenizer = GPT2TokenizerFast.from_pretrained('gpt2')


#TODO: give context window when string is bigger than max length
def score(sentence):
    with torch.no_grad():
        all_log_probs = []
        offset_mapping = []
        start_ind = 0

        while True:
            encodings = tokenizer(sentence[start_ind:], max_length=1022, truncation=True, return_offsets_mapping=True)
            # Convert indexed tokens in a PyTorch tensor
            tensor_input = torch.tensor([[tokenizer.bos_token_id] + encodings['input_ids'] + [tokenizer.eos_token_id]])
            output = model(tensor_input, labels=tensor_input)
            shift_logits = output['logits'][..., :-1, :].contiguous()
            shift_labels = tensor_input[..., 1:].contiguous()
            log_probs = torch.nn.functional.cross_entropy(shift_logits.view(-1, shift_logits.size(-1)), shift_labels.view(-1), reduction='none')
            assert math.exp(sum(log_probs)/len(log_probs)) == math.exp(output['loss'])
            all_log_probs.extend(log_probs[:-1])
            offset_mapping.extend([(i+start_ind, j+start_ind) for i,j in encodings['offset_mapping']])
            if encodings['offset_mapping'][-1][1] + start_ind == len(sentence):
                break
            start_ind = encodings['offset_mapping'][-1][1]
        return np.asarray(all_log_probs), offset_mapping


# Test for above function
a=['there is a book on the desk',
                                'there is a plane on the desk',
                                                'there is a book in the desk']
print([score(i) for i in a])

import pandas as pd
reading_times_df = pd.read_csv("https://raw.githubusercontent.com/languageMIT/naturalstories/master/naturalstories_RTS/processed_RTs.tsv", sep='\t').drop_duplicates()
gpt3_probs = pd.read_csv("https://raw.githubusercontent.com/languageMIT/naturalstories/master/probs/all_stories_gpt3.csv")
gpt3_probs["story"] = gpt3_probs["story"] + 1

reading_times_df.head()

gpt3_probs[gpt3_probs.story==1].head(n=10)

gpt3_probs['len'] = gpt3_probs.groupby("story", sort=False)['offset'].shift(periods=-1, fill_value=0) - gpt3_probs['offset']
gpt3_probs['new_token'] = gpt3_probs.apply(lambda x: x['token'] if x['len'] == len(x['token']) else x['token'] + ' ', axis=1)

# this one takes ~30 seconds to run with the call to "score"
import nltk
nltk.download('punkt')
def string_join(x):
        return ''.join(x)


def get_word_mapping(words):
    offsets = []
    pos = 0
    for w in words:
        offsets.append((pos,pos+len(w)))
        pos += len(w) + 1
    return offsets


def string_to_log_probs(string, probs, offsets):
    words = string.split()
    agg_log_probs = []
    word_mapping = get_word_mapping(words)
    cur_prob = 0
    cur_word_ind = 0
    for lp, ind in zip(probs, offsets):
        cur_prob += lp
        if ind[1] == word_mapping[cur_word_ind][1]:
            agg_log_probs.append(cur_prob)
            cur_prob = 0
            cur_word_ind += 1
    return agg_log_probs


stories_df = gpt3_probs.groupby(by=["story"], sort=False).agg({"new_token":[string_join]}).reset_index()
stories = {}
stories_sent_markers = {}
log_probs = {}
agg_log_probs = {}
for i, s in zip(stories_df['story'], stories_df['new_token', 'string_join']):
    # remove trailing white space
    s = s[:-1]
    stories_sent_markers[i] = np.cumsum([len(sen.split()) for sen in nltk.sent_tokenize(s)])
    stories[i] = s.split()
    log_probs[i] = score(s)
    agg_log_probs[i] = string_to_log_probs(s, log_probs[i][0],log_probs[i][1])


import bisect
reading_times_df['ref_token'] = reading_times_df.apply(lambda x: stories[x['item']][x['zone']-1], axis=1)
reading_times_df['log_prob'] = reading_times_df.apply(lambda x: agg_log_probs[x['item']][x['zone']-1], axis=1)
reading_times_df['sentence_num'] = reading_times_df.apply(lambda x: bisect.bisect(stories_sent_markers[x['item']], x['zone']-1), axis=1)
reading_times_df['word_len'] = reading_times_df.apply(lambda x: len(x['word']), axis=1)

# sanity check: looks like there's a small mispelling somewhere ;)
reading_times_df[reading_times_df['word'] != reading_times_df['ref_token']]

# Commented this out since lmer does this
# # subtract mean reader time (per reader)
# reading_times_df['RT'] -= reading_times_df.groupby(by=["WorkerId"]).transform('mean')["RT"] #agg({"RT": [np.sum, np.mean, np.std], "log_prob": [np.sum, np.mean, np.std]})

# Commented out IPython magic to ensure Python compatibility.
# %R -i reading_times_df

# Commented out IPython magic to ensure Python compatibility.
# %%R
# library(lme4)
# library(MuMIn)

# Commented out IPython magic to ensure Python compatibility.
# %%R
# model <- lmer("RT~log_prob + word_len + (1 | WorkerId)", data=reading_times_df)
# summary(model)


from scipy.special import log_softmax


def ent(x):
    l_soft = log_softmax(-x)
    return -sum(np.exp(l_soft)*l_soft)


def norm_ent(x):
    return ent(x)/np.log(len(x))


aggregate_per_sentence = reading_times_df.groupby(by=["WorkerId","item", "sentence_num"], sort=False).agg({"RT": [np.sum, np.mean, np.count_nonzero], "log_prob": [np.sum, np.mean, np.var, ent, norm_ent], "word_len":np.sum}).reset_index()
aggregate_per_sentence.columns = ['_'.join(col).strip() for col in aggregate_per_sentence.columns.values]

aggregate_per_sentence.corr()

# Commented out IPython magic to ensure Python compatibility.
# %R -i aggregate_per_sentence

# Commented out IPython magic to ensure Python compatibility.
# %%R
# model1 <- lmer(RT_sum~ log_prob_sum  + (1 | WorkerId_), data=aggregate_per_sentence)
# model2 <- lmer(RT_sum~ word_len_sum  + (1 | WorkerId_), data=aggregate_per_sentence)
# model3 <- lmer(RT_sum~ word_len_sum +log_prob_sum + (1 | WorkerId_), data=aggregate_per_sentence)
# print("Conditional R^2:")
# print(r.squaredGLMM(model1)[1])
# print(r.squaredGLMM(model2)[1])
# print(r.squaredGLMM(model3)[1])

# Commented out IPython magic to ensure Python compatibility.
# %%R
# model1 <- lmer(RT_sum~ log_prob_sum  + (1 | WorkerId_), data=aggregate_per_sentence)
# model2 <- lmer(RT_sum~ word_len_sum  + (1 | WorkerId_), data=aggregate_per_sentence)
# model3 <- lmer(RT_sum~ word_len_sum +log_prob_sum + (1 | WorkerId_), data=aggregate_per_sentence)
# model4 <- lmer(RT_sum~ word_len_sum *log_prob_sum + (1 | WorkerId_), data=aggregate_per_sentence)
# print("Conditional R^2:")
# print(r.squaredGLMM(model1)[1])
# print(r.squaredGLMM(model2)[1])
# print(r.squaredGLMM(model3)[1])
# print(r.squaredGLMM(model4)[1])
# print(AIC(model1))
# print(AIC(model2))
# print(AIC(model3))
# print(AIC(model4))

# Commented out IPython magic to ensure Python compatibility.
# %%R
# library(ggplot2)
# ggplot(aes(x = log_prob_std, y = RT_sum ), data=aggregate_per_sentence) + geom_point()

import pickle
with open('probs_dict.pkl', 'rb') as handle:
        log_probs = pickle.load( handle)
len(log_probs)

"""# Fine-tuning a language model

In this notebook, we'll see how to fine-tune one of the [ðŸ¤— Transformers](https://github.com/huggingface/transformers) model on a language modeling tasks. We will cover two types of language modeling tasks which are:

- Causal language modeling: the model has to predict the next token in the sentence (so the labels are the same as the inputs shifted to the right). To make sure the model does not cheat, it gets an attention mask that will prevent it to access the tokens after token i when trying to predict the token i+1 in the sentence.

![Widget inference representing the causal language modeling task](images/causal_language_modeling.png)

- Masked language modeling: the model has to predict some tokens that are masked in the input. It still has access to the whole sentence, so it can use the tokens before and after the tokens masked to predict their value.

![Widget inference representing the masked language modeling task](images/masked_language_modeling.png)

We will see how to easily load and preprocess the dataset for each one of those tasks, and how to use the `Trainer` API to fine-tune a model on it.

A script version of this notebook you can directly run on a distributed environment or on TPU is available in our [examples folder](https://github.com/huggingface/transformers/tree/master/examples).

## Preparing the dataset

For each of those tasks, we will use the [Wikitext 2]() dataset as an example. You can load it very easily with the ðŸ¤— Datasets library.
"""

from datasets import load_dataset
datasets = load_dataset('wikitext', 'wikitext-2-raw-v1')

"""You can replace the dataset above with any dataset hosted on [the hub](https://huggingface.co/datasets) or use your own files. Just uncomment the following cell and replace the paths with values that will lead to your files:"""

# datasets = load_dataset("text", data_files={"train": path_to_train.txt, "validation": path_to_validation.txt}

"""You can also load datasets from a csv or a JSON file, see the [full documentation](https://huggingface.co/docs/datasets/loading_datasets.html#from-local-files) for more information.

To access an actual element, you need to select a split first, then give an index:
"""

datasets["train"][10]

"""To get a sense of what the data looks like, the following function will show some examples picked randomly in the dataset."""

from datasets import ClassLabel
import random
import pandas as pd
from IPython.display import display, HTML

def show_random_elements(dataset, num_examples=10):
        assert num_examples <= len(dataset), "Can't pick more elements than there are in the dataset."
        picks = []
        for _ in range(num_examples):
                pick = random.randint(0, len(dataset)-1)
                while pick in picks:
                        pick = random.randint(0, len(dataset)-1)
                picks.append(pick)

        df = pd.DataFrame(dataset[picks])
        for column, typ in dataset.features.items():
                if isinstance(typ, ClassLabel):
                        df[column] = df[column].transform(lambda i: typ.names[i])
        display(HTML(df.to_html()))

show_random_elements(datasets["train"])

"""As we can see, some of the texts are a full paragraph of a Wikipedia article while others are just titles or empty lines.

## Causal Language modeling

For causal language modeling (CLM) we are going to take all the texts in our dataset and concatenate them after they are tokenized. Then we will split them in examples of a certain sequence length. This way the model will receive chunks of contiguous text that may look like:
```
part of text 1
```
or
```
end of text 1 [BOS_TOKEN] beginning of text 2
```
depending on whether they span over several of the original texts in the dataset or not. The labels will be the same as the inputs, shifted to the left.

We will use the [`distilgpt2`](https://huggingface.co/distilgpt2) model for this example. You can pick any of the checkpoints listed [here](https://huggingface.co/models?filter=causal-lm) instead:
"""

model_checkpoint = "distilgpt2"

"""To tokenize all our texts with the same vocabulary that was used when training the model, we have to download a pretrained tokenizer. This is all done by the `AutoTokenizer` class:"""

from transformers import AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained(model_checkpoint, use_fast=True)

"""We can now call the tokenizer on all our texts. This is very simple, using the [`map`](https://huggingface.co/docs/datasets/package_reference/main_classes.html#datasets.Dataset.map) method from the Datasets library. First we define a function that call the tokenizer on our texts:"""

def tokenize_function(examples):
        return tokenizer(examples["text"])

"""Then we apply it to all the splits in our `datasets` object, using `batched=True` and 4 processes to speed up the preprocessing. We won't need the `text` column afterward, so we discard it."""

tokenized_datasets = datasets.map(tokenize_function, batched=True, num_proc=4, remove_columns=["text"])

"""If we now look at an element of our datasets, we will see the text have been replaced by the `input_ids` the model will need:"""

tokenized_datasets["train"][1]

"""Now for the harder part: we need to concatenate all our texts together then split the result in small chunks of a certain `block_size`. To do this, we will use the `map` method again, with the option `batched=True`. This option actually lets us change the number of examples in the datasets by returning a different number of examples than we got. This way, we can create our new samples from a batch of examples.

First, we grab the maximum length our model was pretrained with. This might be a big too big to fit in your GPU RAM, so here we take a bit less at just 128.
"""

# block_size = tokenizer.model_max_length
block_size = 128

"""Then we write the preprocessing function that will group our texts:"""

def group_texts(examples):
        # Concatenate all texts.
        concatenated_examples = {k: sum(examples[k], []) for k in examples.keys()}
        total_length = len(concatenated_examples[list(examples.keys())[0]])
        # We drop the small remainder, we could add padding if the model supported it instead of this drop, you can
                # customize this part to your needs.
        total_length = (total_length // block_size) * block_size
        # Split by chunks of max_len.
        result = {
                k: [t[i : i + block_size] for i in range(0, total_length, block_size)]
                for k, t in concatenated_examples.items()
        }
        result["labels"] = result["input_ids"].copy()
        return result

"""First note that we duplicate the inputs for our labels. This is because the model of the ðŸ¤— Transformers library apply the shifting to the right, so we don't need to do it manually.

Also note that by default, the `map` method will send a batch of 1,000 examples to be treated by the preprocessing function. So here, we will drop the remainder to make the concatenated tokenized texts a multiple of `block_size` every 1,000 examples. You can adjust this behavior by passing a higher batch size (which will also be processed slower). You can also speed-up the preprocessing by using multiprocessing:
"""

lm_datasets = tokenized_datasets.map(
        group_texts,
        batched=True,
        batch_size=1000,
        num_proc=4,
)

"""And we can check our datasets have changed: now the samples contain chunks of `block_size` contiguous tokens, potentially spanning over several of our original texts."""

tokenizer.decode(lm_datasets["train"][1]["input_ids"])

"""Now that the data has been cleaned, we're ready to instantiate our `Trainer`. We will a model:"""

from transformers import AutoModelForCausalLM
model = AutoModelForCausalLM.from_pretrained(model_checkpoint)

"""And some `TrainingArguments`:"""

from transformers import Trainer, TrainingArguments

training_args = TrainingArguments(
        "test-clm",
        evaluation_strategy = "epoch",
        learning_rate=2e-5,
        weight_decay=0.01,
)

"""We pass along all of those to the `Trainer` class:"""

trainer = Trainer(
        model=model,
        args=training_args,
        train_dataset=lm_datasets["train"],
        eval_dataset=lm_datasets["validation"],
)

"""And we can train our model:"""

trainer.train()

"""Once the training is completed, we can evaluate our model and get its perplexity on the validation set like this:"""

import math
eval_results = trainer.evaluate()
print(f"Perplexity: {math.exp(eval_results['eval_loss']):.2f}")

"""## Masked language modeling

For masked language modeling (MLM) we are going to use the same preprocessing as before for our dataset with one additional step: we will randomly mask some tokens (by replacing them by `[MASK]`) and the labels will be adjusted to only include the masked tokens (we don't have to predict the non-masked tokens).

We will use the [`distilroberta-base`](https://huggingface.co/distilroberta-base) model for this example. You can pick any of the checkpoints listed [here](https://huggingface.co/models?filter=masked-lm) instead:
"""

model_checkpoint = "distilroberta-base"

"""We can apply the same tokenization function as before, we just need to update our tokenizer to use the checkpoint we just picked:"""

tokenizer = AutoTokenizer.from_pretrained(model_checkpoint, use_fast=True)
tokenized_datasets = datasets.map(tokenize_function, batched=True, num_proc=4, remove_columns=["text"])

"""And like before, we group texts together and chunk them in samples of length `block_size`. You can skip that step if your dataset is composed of individual sentences."""

lm_datasets = tokenized_datasets.map(
        group_texts,
        batched=True,
        batch_size=1000,
        num_proc=4,
)

"""The rest is very similar to what we had, with two exceptions. First we use a model suitable for masked LM:"""

from transformers import AutoModelForMaskedLM
model = AutoModelForMaskedLM.from_pretrained(model_checkpoint)

"""And second, we use a special `data_collator`. The `data_collator` is a function that is responsible of taking the samples and batching them in tensors. In the previous example, we had nothing special to do, so we just used the default for this argument. Here we want to do the random-masking. We could do it as a pre-processing step (like the tokenization) but then the tokens would always be masked the same way at each epoch. By doing this step inside the `data_collator`, we ensure this random masking is done in a new way each time we go over the data.

To do this masking for us, the library provides a `DataCollatorForLanguageModeling`. We can adjust the probability of the masking:
"""

from transformers import DataCollatorForLanguageModeling
data_collator = DataCollatorForLanguageModeling(tokenizer=tokenizer, mlm_probability=0.15)

"""Then we just have to pass everything to `Trainer` and begin training:"""

trainer = Trainer(
        model=model,
        args=training_args,
        train_dataset=lm_datasets["train"],
        eval_dataset=lm_datasets["validation"],
        data_collator=data_collator,
)

trainer.train()

"""Like before, we can evaluate our model on the validation set. The perplexity is much lower than for the CLM objective because for the MLM objective, we only have to make predictions for the masked tokens (which represent 15% of the total here) while having access to the rest of the tokens. It's thus an easier task for the model."""

eval_results = trainer.evaluate()
print(f"Perplexity: {math.exp(eval_results['eval_loss']):.2f}")

"""Don't forget to [update your model](https://huggingface.co/transformers/model_sharing.html) on the [ðŸ¤— Model Hub](https://huggingface.co/models). You can then use it only to generate results like the one shown in the first picture of this notebook!|"""

